///
/// RAGConfig.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/**
 * Represents an instance of `RAGConfig`, backed by a C++ struct.
 */
public typealias RAGConfig = margelo.nitro.runanywhere.rag.RAGConfig

public extension RAGConfig {
  private typealias bridge = margelo.nitro.runanywhere.rag.bridge.swift

  /**
   * Create a new instance of `RAGConfig`.
   */
  init(embeddingModelPath: String, llmModelPath: String, embeddingDimension: Double?, topK: Double?, similarityThreshold: Double?, maxContextTokens: Double?, chunkSize: Double?, chunkOverlap: Double?, promptTemplate: String?, embeddingConfigJson: String?, llmConfigJson: String?) {
    self.init(std.string(embeddingModelPath), std.string(llmModelPath), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = embeddingDimension {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = topK {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = similarityThreshold {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = maxContextTokens {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = chunkSize {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = chunkOverlap {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = promptTemplate {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = embeddingConfigJson {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = llmConfigJson {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }())
  }

  var embeddingModelPath: String {
    @inline(__always)
    get {
      return String(self.__embeddingModelPath)
    }
    @inline(__always)
    set {
      self.__embeddingModelPath = std.string(newValue)
    }
  }
  
  var llmModelPath: String {
    @inline(__always)
    get {
      return String(self.__llmModelPath)
    }
    @inline(__always)
    set {
      self.__llmModelPath = std.string(newValue)
    }
  }
  
  var embeddingDimension: Double? {
    @inline(__always)
    get {
      return self.__embeddingDimension.value
    }
    @inline(__always)
    set {
      self.__embeddingDimension = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var topK: Double? {
    @inline(__always)
    get {
      return self.__topK.value
    }
    @inline(__always)
    set {
      self.__topK = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var similarityThreshold: Double? {
    @inline(__always)
    get {
      return self.__similarityThreshold.value
    }
    @inline(__always)
    set {
      self.__similarityThreshold = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var maxContextTokens: Double? {
    @inline(__always)
    get {
      return self.__maxContextTokens.value
    }
    @inline(__always)
    set {
      self.__maxContextTokens = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var chunkSize: Double? {
    @inline(__always)
    get {
      return self.__chunkSize.value
    }
    @inline(__always)
    set {
      self.__chunkSize = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var chunkOverlap: Double? {
    @inline(__always)
    get {
      return self.__chunkOverlap.value
    }
    @inline(__always)
    set {
      self.__chunkOverlap = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var promptTemplate: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__promptTemplate) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__promptTemplate)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__promptTemplate = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var embeddingConfigJson: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__embeddingConfigJson) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__embeddingConfigJson)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__embeddingConfigJson = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var llmConfigJson: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__llmConfigJson) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__llmConfigJson)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__llmConfigJson = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
}
