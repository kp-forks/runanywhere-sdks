///
/// JRAGConfig.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "RAGConfig.hpp"

#include <optional>
#include <string>

namespace margelo::nitro::runanywhere::rag {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "RAGConfig" and the the Kotlin data class "RAGConfig".
   */
  struct JRAGConfig final: public jni::JavaClass<JRAGConfig> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/runanywhere/rag/RAGConfig;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct RAGConfig by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    RAGConfig toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldEmbeddingModelPath = clazz->getField<jni::JString>("embeddingModelPath");
      jni::local_ref<jni::JString> embeddingModelPath = this->getFieldValue(fieldEmbeddingModelPath);
      static const auto fieldLlmModelPath = clazz->getField<jni::JString>("llmModelPath");
      jni::local_ref<jni::JString> llmModelPath = this->getFieldValue(fieldLlmModelPath);
      static const auto fieldEmbeddingDimension = clazz->getField<jni::JDouble>("embeddingDimension");
      jni::local_ref<jni::JDouble> embeddingDimension = this->getFieldValue(fieldEmbeddingDimension);
      static const auto fieldTopK = clazz->getField<jni::JDouble>("topK");
      jni::local_ref<jni::JDouble> topK = this->getFieldValue(fieldTopK);
      static const auto fieldSimilarityThreshold = clazz->getField<jni::JDouble>("similarityThreshold");
      jni::local_ref<jni::JDouble> similarityThreshold = this->getFieldValue(fieldSimilarityThreshold);
      static const auto fieldMaxContextTokens = clazz->getField<jni::JDouble>("maxContextTokens");
      jni::local_ref<jni::JDouble> maxContextTokens = this->getFieldValue(fieldMaxContextTokens);
      static const auto fieldChunkSize = clazz->getField<jni::JDouble>("chunkSize");
      jni::local_ref<jni::JDouble> chunkSize = this->getFieldValue(fieldChunkSize);
      static const auto fieldChunkOverlap = clazz->getField<jni::JDouble>("chunkOverlap");
      jni::local_ref<jni::JDouble> chunkOverlap = this->getFieldValue(fieldChunkOverlap);
      static const auto fieldPromptTemplate = clazz->getField<jni::JString>("promptTemplate");
      jni::local_ref<jni::JString> promptTemplate = this->getFieldValue(fieldPromptTemplate);
      static const auto fieldEmbeddingConfigJson = clazz->getField<jni::JString>("embeddingConfigJson");
      jni::local_ref<jni::JString> embeddingConfigJson = this->getFieldValue(fieldEmbeddingConfigJson);
      static const auto fieldLlmConfigJson = clazz->getField<jni::JString>("llmConfigJson");
      jni::local_ref<jni::JString> llmConfigJson = this->getFieldValue(fieldLlmConfigJson);
      return RAGConfig(
        embeddingModelPath->toStdString(),
        llmModelPath->toStdString(),
        embeddingDimension != nullptr ? std::make_optional(embeddingDimension->value()) : std::nullopt,
        topK != nullptr ? std::make_optional(topK->value()) : std::nullopt,
        similarityThreshold != nullptr ? std::make_optional(similarityThreshold->value()) : std::nullopt,
        maxContextTokens != nullptr ? std::make_optional(maxContextTokens->value()) : std::nullopt,
        chunkSize != nullptr ? std::make_optional(chunkSize->value()) : std::nullopt,
        chunkOverlap != nullptr ? std::make_optional(chunkOverlap->value()) : std::nullopt,
        promptTemplate != nullptr ? std::make_optional(promptTemplate->toStdString()) : std::nullopt,
        embeddingConfigJson != nullptr ? std::make_optional(embeddingConfigJson->toStdString()) : std::nullopt,
        llmConfigJson != nullptr ? std::make_optional(llmConfigJson->toStdString()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JRAGConfig::javaobject> fromCpp(const RAGConfig& value) {
      using JSignature = JRAGConfig(jni::alias_ref<jni::JString>, jni::alias_ref<jni::JString>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JDouble>, jni::alias_ref<jni::JString>, jni::alias_ref<jni::JString>, jni::alias_ref<jni::JString>);
      static const auto clazz = javaClassStatic();
      static const auto create = clazz->getStaticMethod<JSignature>("fromCpp");
      return create(
        clazz,
        jni::make_jstring(value.embeddingModelPath),
        jni::make_jstring(value.llmModelPath),
        value.embeddingDimension.has_value() ? jni::JDouble::valueOf(value.embeddingDimension.value()) : nullptr,
        value.topK.has_value() ? jni::JDouble::valueOf(value.topK.value()) : nullptr,
        value.similarityThreshold.has_value() ? jni::JDouble::valueOf(value.similarityThreshold.value()) : nullptr,
        value.maxContextTokens.has_value() ? jni::JDouble::valueOf(value.maxContextTokens.value()) : nullptr,
        value.chunkSize.has_value() ? jni::JDouble::valueOf(value.chunkSize.value()) : nullptr,
        value.chunkOverlap.has_value() ? jni::JDouble::valueOf(value.chunkOverlap.value()) : nullptr,
        value.promptTemplate.has_value() ? jni::make_jstring(value.promptTemplate.value()) : nullptr,
        value.embeddingConfigJson.has_value() ? jni::make_jstring(value.embeddingConfigJson.value()) : nullptr,
        value.llmConfigJson.has_value() ? jni::make_jstring(value.llmConfigJson.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::runanywhere::rag
