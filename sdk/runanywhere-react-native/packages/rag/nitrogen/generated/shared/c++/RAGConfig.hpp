///
/// RAGConfig.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif



#include <string>
#include <optional>

namespace margelo::nitro::runanywhere::rag {

  /**
   * A struct which can be represented as a JavaScript object (RAGConfig).
   */
  struct RAGConfig {
  public:
    std::string embeddingModelPath     SWIFT_PRIVATE;
    std::string llmModelPath     SWIFT_PRIVATE;
    std::optional<double> embeddingDimension     SWIFT_PRIVATE;
    std::optional<double> topK     SWIFT_PRIVATE;
    std::optional<double> similarityThreshold     SWIFT_PRIVATE;
    std::optional<double> maxContextTokens     SWIFT_PRIVATE;
    std::optional<double> chunkSize     SWIFT_PRIVATE;
    std::optional<double> chunkOverlap     SWIFT_PRIVATE;
    std::optional<std::string> promptTemplate     SWIFT_PRIVATE;
    std::optional<std::string> embeddingConfigJson     SWIFT_PRIVATE;
    std::optional<std::string> llmConfigJson     SWIFT_PRIVATE;

  public:
    RAGConfig() = default;
    explicit RAGConfig(std::string embeddingModelPath, std::string llmModelPath, std::optional<double> embeddingDimension, std::optional<double> topK, std::optional<double> similarityThreshold, std::optional<double> maxContextTokens, std::optional<double> chunkSize, std::optional<double> chunkOverlap, std::optional<std::string> promptTemplate, std::optional<std::string> embeddingConfigJson, std::optional<std::string> llmConfigJson): embeddingModelPath(embeddingModelPath), llmModelPath(llmModelPath), embeddingDimension(embeddingDimension), topK(topK), similarityThreshold(similarityThreshold), maxContextTokens(maxContextTokens), chunkSize(chunkSize), chunkOverlap(chunkOverlap), promptTemplate(promptTemplate), embeddingConfigJson(embeddingConfigJson), llmConfigJson(llmConfigJson) {}
  };

} // namespace margelo::nitro::runanywhere::rag

namespace margelo::nitro {

  // C++ RAGConfig <> JS RAGConfig (object)
  template <>
  struct JSIConverter<margelo::nitro::runanywhere::rag::RAGConfig> final {
    static inline margelo::nitro::runanywhere::rag::RAGConfig fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::runanywhere::rag::RAGConfig(
        JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, "embeddingModelPath")),
        JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, "llmModelPath")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "embeddingDimension")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "topK")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "similarityThreshold")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "maxContextTokens")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "chunkSize")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "chunkOverlap")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "promptTemplate")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "embeddingConfigJson")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "llmConfigJson"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::runanywhere::rag::RAGConfig& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "embeddingModelPath", JSIConverter<std::string>::toJSI(runtime, arg.embeddingModelPath));
      obj.setProperty(runtime, "llmModelPath", JSIConverter<std::string>::toJSI(runtime, arg.llmModelPath));
      obj.setProperty(runtime, "embeddingDimension", JSIConverter<std::optional<double>>::toJSI(runtime, arg.embeddingDimension));
      obj.setProperty(runtime, "topK", JSIConverter<std::optional<double>>::toJSI(runtime, arg.topK));
      obj.setProperty(runtime, "similarityThreshold", JSIConverter<std::optional<double>>::toJSI(runtime, arg.similarityThreshold));
      obj.setProperty(runtime, "maxContextTokens", JSIConverter<std::optional<double>>::toJSI(runtime, arg.maxContextTokens));
      obj.setProperty(runtime, "chunkSize", JSIConverter<std::optional<double>>::toJSI(runtime, arg.chunkSize));
      obj.setProperty(runtime, "chunkOverlap", JSIConverter<std::optional<double>>::toJSI(runtime, arg.chunkOverlap));
      obj.setProperty(runtime, "promptTemplate", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.promptTemplate));
      obj.setProperty(runtime, "embeddingConfigJson", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.embeddingConfigJson));
      obj.setProperty(runtime, "llmConfigJson", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.llmConfigJson));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, "embeddingModelPath"))) return false;
      if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, "llmModelPath"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "embeddingDimension"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "topK"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "similarityThreshold"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "maxContextTokens"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "chunkSize"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "chunkOverlap"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "promptTemplate"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "embeddingConfigJson"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "llmConfigJson"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
